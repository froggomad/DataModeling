# Data Modeling Guided Project

- [ ]  ðŸ›‘ Data modeling, very simply put is the act of turning real world (or imagined) objects into data representations.
    - [ ] We essentially break things down into their parts, and represent those parts. For instance, our Vehicle from yesterday.
    - [ ] Data modeling is much more complex than that. For our purposes, we want to look at making our data model flexible and easily maintainable, as well as realistic toward achieving whatever goal we set out to achieve.
    - [ ] Protocols help keep our code easily maintainable by allowing us to break our code down into easily reusable requirements that multiple types can conform to
- [ ]  ðŸ›‘ Remember, protocols guarantee that types conforming to them will have certain properties and/or methods
- [ ]  ðŸ›‘ Remember, types can conform to multiple protocols and protocols can inherit multiple protocols
- [ ]  ðŸ›‘ Instead of making one big protocol, we can make several smaller ones, then combine them into larger ones as necessary. Example Player, User, LoginUser (all players are users, only the current player is a LoginUser)
- [ ]  Lets start by making a protocol for a user that can log in locally (protocol LoginUser)
    - [ ]  var id: Int
    - [ ]  var username: String
    - [ ]  var email: String
    - [ ]  var password: String
    - [ ]  var phone: Int?
    - [ ]  var birthday: Date? { get }
- [ ]  Lets make a protocol for other users to conform to protocol User
    - [ ]  var id: Int
    - [ ]  var username: String { get }
    - [ ]  ðŸ›‘ We just used those. This is a perfect opportunity for another protocol
    - [ ]  Let's make a protocol called Identifiable that holds a name and id
- [ ]  Let's refactor and conform User to Identifiable and LoginUser to User
    - [ ]  This way we get the username property
    - [ ]  ðŸ›‘ Does everyone understand what we just did?
- [ ]  Let's make a Player Protocol called PlayerProtocol and finish setting up our user.
    - [ ]  hitPoints: Int { get set }
    - [ ]  damageDealt: Int { get set }
    - [ ]  damageAbsorbed: Int { get set }
- [ ]  Let's make a Monster Protocol called MonsterProtocol and set up our monster.
    - [ ]  hitPoints: Int { get set }
    - [ ]  damageDealt: Int { get set }
    - [ ]  damageAbsorbed: Int { get set }
    - [ ]  We'll probably have lots of monsters. Let's make a way to set up our monster easily
        - [ ]  enum MonsterType (we'll use this later)
        - [ ]  var type: MonsterType
    - [ ]  Oh look, we have some things in common. How about a fightable protocol to store hitPoints, damageDealt, and DamageAbsorbed?
    - [ ]  We need our player and monster to conform to Fightable and Identifiable, but Monster has a custom property. How can we refactor to include a common type? We also need movement speed or points (realtime or turn based)
    - [ ]  Let's make a player struct
    - [ ]  Let's make a struct for other players
    - [ ]  Let's make a monster struct
        - [ ]  lets setup our init using the monster type
    - [ ]  Let's make an instance of player and an instance of monster. Notice we can store them in the same array if the array conforms to a protocol both types conform to
        - [ ]  var mobs: [Mob] = [ goblin, player ]
        - [ ]  print(mobs)
        - [ ]  Let's clean that up (CustomStringConvertible on Identifiable)
        - [ ]  Provide default implementation for Identifiable so that description returns name
